{"ast":null,"code":"import { InputRule } from 'prosemirror-inputrules';\nconst isMarkActive = (state, type) => {\n  const {\n    from,\n    $from,\n    to,\n    empty\n  } = state.selection;\n  if (empty) {\n    return Boolean(type.isInSet(state.storedMarks || $from.marks()));\n  }\n  return state.doc.rangeHasMark(from, to, type);\n};\nconst findNodeType = (type, $from) => {\n  for (let i = $from.depth; i > 0; i -= 1) {\n    if ($from.node(i).type === type) {\n      return $from.node(i).type;\n    }\n  }\n  return null;\n};\nconst isNodeActive = (state, type, attrs = {}) => {\n  const {\n    selection\n  } = state;\n  const {\n    $from,\n    to\n  } = selection;\n  const node = findNodeType(type, $from);\n  if (!Object.entries(attrs).length || !node) {\n    return Boolean(node);\n  }\n  return to <= $from.end() && $from.parent.hasMarkup(type, attrs);\n};\nconst getSelectionMarks = state => {\n  let marks = [];\n  const {\n    selection,\n    storedMarks\n  } = state;\n  const {\n    from,\n    to,\n    empty,\n    $from\n  } = selection;\n  if (empty) {\n    marks = storedMarks || $from.marks();\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks = [...marks, ...node.marks];\n    });\n  }\n  return marks;\n};\nconst getSelectionNodes = state => {\n  const nodes = [];\n  const {\n    selection: {\n      from,\n      to\n    }\n  } = state;\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node);\n  });\n  return nodes;\n};\n\n// Ref: https://github.com/ProseMirror/prosemirror-commands/blob/master/src/commands.js\nconst markApplies = (doc, ranges, type) => {\n  for (const range of ranges) {\n    const {\n      $from,\n      $to\n    } = range;\n    let canApply = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n    doc.nodesBetween($from.pos, $to.pos, node => {\n      if (canApply) {\n        return false;\n      }\n      canApply = node.inlineContent && node.type.allowsMarkType(type);\n      return true;\n    });\n    if (canApply) {\n      return true;\n    }\n  }\n  return false;\n};\nconst markInputRule = (regexp, markType, attrs) => {\n  return new InputRule(regexp, (state, match, start, end) => {\n    const {\n      tr\n    } = state;\n    const from = start;\n    let to = end;\n    const [fullMatch,, content] = match;\n    const noOfStartSpaces = fullMatch.search(/\\S/);\n    if (content) {\n      const textStart = start + fullMatch.indexOf(content);\n      const textEnd = textStart + content.length;\n      if (textEnd < end) {\n        tr.delete(textEnd, end);\n      }\n      if (textStart > start) {\n        tr.delete(start + noOfStartSpaces, textStart);\n      }\n      to = start + content.length + noOfStartSpaces;\n    }\n    tr.addMark(from, to, markType.create(attrs));\n    tr.removeStoredMark(markType);\n    return tr;\n  });\n};\nconst canInsert = (state, nodeType) => {\n  const {\n    $from\n  } = state.selection;\n  for (let d = $from.depth; d >= 0; d -= 1) {\n    const index = $from.index(d);\n    if ($from.node(d).canReplaceWith(index, index, nodeType)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { canInsert, getSelectionMarks, getSelectionNodes, isMarkActive, isNodeActive, markApplies, markInputRule };","map":{"version":3,"names":["InputRule","isMarkActive","state","type","from","$from","to","empty","selection","Boolean","isInSet","storedMarks","marks","doc","rangeHasMark","findNodeType","i","depth","node","isNodeActive","attrs","Object","entries","length","end","parent","hasMarkup","getSelectionMarks","nodesBetween","getSelectionNodes","nodes","push","markApplies","ranges","range","$to","canApply","allowsMarkType","pos","inlineContent","markInputRule","regexp","markType","match","start","tr","fullMatch","content","noOfStartSpaces","search","textStart","indexOf","textEnd","delete","addMark","create","removeStoredMark","canInsert","nodeType","d","index","canReplaceWith"],"sources":["/Users/diakaria/Documents/SAITECH/ANGULAR/visitrack/node_modules/ngx-editor/fesm2022/ngx-editor-helpers.mjs"],"sourcesContent":["import { InputRule } from 'prosemirror-inputrules';\n\nconst isMarkActive = (state, type) => {\n    const { from, $from, to, empty } = state.selection;\n    if (empty) {\n        return Boolean(type.isInSet(state.storedMarks || $from.marks()));\n    }\n    return state.doc.rangeHasMark(from, to, type);\n};\n\nconst findNodeType = (type, $from) => {\n    for (let i = $from.depth; i > 0; i -= 1) {\n        if ($from.node(i).type === type) {\n            return $from.node(i).type;\n        }\n    }\n    return null;\n};\nconst isNodeActive = (state, type, attrs = {}) => {\n    const { selection } = state;\n    const { $from, to } = selection;\n    const node = findNodeType(type, $from);\n    if (!Object.entries(attrs).length || !node) {\n        return Boolean(node);\n    }\n    return to <= $from.end() && $from.parent.hasMarkup(type, attrs);\n};\n\nconst getSelectionMarks = (state) => {\n    let marks = [];\n    const { selection, storedMarks } = state;\n    const { from, to, empty, $from } = selection;\n    if (empty) {\n        marks = storedMarks || $from.marks();\n    }\n    else {\n        state.doc.nodesBetween(from, to, (node) => {\n            marks = [...marks, ...node.marks];\n        });\n    }\n    return marks;\n};\n\nconst getSelectionNodes = (state) => {\n    const nodes = [];\n    const { selection: { from, to } } = state;\n    state.doc.nodesBetween(from, to, (node) => {\n        nodes.push(node);\n    });\n    return nodes;\n};\n\n// Ref: https://github.com/ProseMirror/prosemirror-commands/blob/master/src/commands.js\nconst markApplies = (doc, ranges, type) => {\n    for (const range of ranges) {\n        const { $from, $to } = range;\n        let canApply = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, (node) => {\n            if (canApply) {\n                return false;\n            }\n            canApply = node.inlineContent && node.type.allowsMarkType(type);\n            return true;\n        });\n        if (canApply) {\n            return true;\n        }\n    }\n    return false;\n};\n\nconst markInputRule = (regexp, markType, attrs) => {\n    return new InputRule(regexp, (state, match, start, end) => {\n        const { tr } = state;\n        const from = start;\n        let to = end;\n        const [fullMatch, , content] = match;\n        const noOfStartSpaces = fullMatch.search(/\\S/);\n        if (content) {\n            const textStart = start + fullMatch.indexOf(content);\n            const textEnd = textStart + content.length;\n            if (textEnd < end) {\n                tr.delete(textEnd, end);\n            }\n            if (textStart > start) {\n                tr.delete(start + noOfStartSpaces, textStart);\n            }\n            to = start + content.length + noOfStartSpaces;\n        }\n        tr.addMark(from, to, markType.create(attrs));\n        tr.removeStoredMark(markType);\n        return tr;\n    });\n};\n\nconst canInsert = (state, nodeType) => {\n    const { $from } = state.selection;\n    for (let d = $from.depth; d >= 0; d -= 1) {\n        const index = $from.index(d);\n        if ($from.node(d).canReplaceWith(index, index, nodeType)) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { canInsert, getSelectionMarks, getSelectionNodes, isMarkActive, isNodeActive, markApplies, markInputRule };\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,wBAAwB;AAElD,MAAMC,YAAY,GAAGA,CAACC,KAAK,EAAEC,IAAI,KAAK;EAClC,MAAM;IAAEC,IAAI;IAAEC,KAAK;IAAEC,EAAE;IAAEC;EAAM,CAAC,GAAGL,KAAK,CAACM,SAAS;EAClD,IAAID,KAAK,EAAE;IACP,OAAOE,OAAO,CAACN,IAAI,CAACO,OAAO,CAACR,KAAK,CAACS,WAAW,IAAIN,KAAK,CAACO,KAAK,CAAC,CAAC,CAAC,CAAC;EACpE;EACA,OAAOV,KAAK,CAACW,GAAG,CAACC,YAAY,CAACV,IAAI,EAAEE,EAAE,EAAEH,IAAI,CAAC;AACjD,CAAC;AAED,MAAMY,YAAY,GAAGA,CAACZ,IAAI,EAAEE,KAAK,KAAK;EAClC,KAAK,IAAIW,CAAC,GAAGX,KAAK,CAACY,KAAK,EAAED,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;IACrC,IAAIX,KAAK,CAACa,IAAI,CAACF,CAAC,CAAC,CAACb,IAAI,KAAKA,IAAI,EAAE;MAC7B,OAAOE,KAAK,CAACa,IAAI,CAACF,CAAC,CAAC,CAACb,IAAI;IAC7B;EACJ;EACA,OAAO,IAAI;AACf,CAAC;AACD,MAAMgB,YAAY,GAAGA,CAACjB,KAAK,EAAEC,IAAI,EAAEiB,KAAK,GAAG,CAAC,CAAC,KAAK;EAC9C,MAAM;IAAEZ;EAAU,CAAC,GAAGN,KAAK;EAC3B,MAAM;IAAEG,KAAK;IAAEC;EAAG,CAAC,GAAGE,SAAS;EAC/B,MAAMU,IAAI,GAAGH,YAAY,CAACZ,IAAI,EAAEE,KAAK,CAAC;EACtC,IAAI,CAACgB,MAAM,CAACC,OAAO,CAACF,KAAK,CAAC,CAACG,MAAM,IAAI,CAACL,IAAI,EAAE;IACxC,OAAOT,OAAO,CAACS,IAAI,CAAC;EACxB;EACA,OAAOZ,EAAE,IAAID,KAAK,CAACmB,GAAG,CAAC,CAAC,IAAInB,KAAK,CAACoB,MAAM,CAACC,SAAS,CAACvB,IAAI,EAAEiB,KAAK,CAAC;AACnE,CAAC;AAED,MAAMO,iBAAiB,GAAIzB,KAAK,IAAK;EACjC,IAAIU,KAAK,GAAG,EAAE;EACd,MAAM;IAAEJ,SAAS;IAAEG;EAAY,CAAC,GAAGT,KAAK;EACxC,MAAM;IAAEE,IAAI;IAAEE,EAAE;IAAEC,KAAK;IAAEF;EAAM,CAAC,GAAGG,SAAS;EAC5C,IAAID,KAAK,EAAE;IACPK,KAAK,GAAGD,WAAW,IAAIN,KAAK,CAACO,KAAK,CAAC,CAAC;EACxC,CAAC,MACI;IACDV,KAAK,CAACW,GAAG,CAACe,YAAY,CAACxB,IAAI,EAAEE,EAAE,EAAGY,IAAI,IAAK;MACvCN,KAAK,GAAG,CAAC,GAAGA,KAAK,EAAE,GAAGM,IAAI,CAACN,KAAK,CAAC;IACrC,CAAC,CAAC;EACN;EACA,OAAOA,KAAK;AAChB,CAAC;AAED,MAAMiB,iBAAiB,GAAI3B,KAAK,IAAK;EACjC,MAAM4B,KAAK,GAAG,EAAE;EAChB,MAAM;IAAEtB,SAAS,EAAE;MAAEJ,IAAI;MAAEE;IAAG;EAAE,CAAC,GAAGJ,KAAK;EACzCA,KAAK,CAACW,GAAG,CAACe,YAAY,CAACxB,IAAI,EAAEE,EAAE,EAAGY,IAAI,IAAK;IACvCY,KAAK,CAACC,IAAI,CAACb,IAAI,CAAC;EACpB,CAAC,CAAC;EACF,OAAOY,KAAK;AAChB,CAAC;;AAED;AACA,MAAME,WAAW,GAAGA,CAACnB,GAAG,EAAEoB,MAAM,EAAE9B,IAAI,KAAK;EACvC,KAAK,MAAM+B,KAAK,IAAID,MAAM,EAAE;IACxB,MAAM;MAAE5B,KAAK;MAAE8B;IAAI,CAAC,GAAGD,KAAK;IAC5B,IAAIE,QAAQ,GAAG/B,KAAK,CAACY,KAAK,KAAK,CAAC,GAAGJ,GAAG,CAACV,IAAI,CAACkC,cAAc,CAAClC,IAAI,CAAC,GAAG,KAAK;IACxEU,GAAG,CAACe,YAAY,CAACvB,KAAK,CAACiC,GAAG,EAAEH,GAAG,CAACG,GAAG,EAAGpB,IAAI,IAAK;MAC3C,IAAIkB,QAAQ,EAAE;QACV,OAAO,KAAK;MAChB;MACAA,QAAQ,GAAGlB,IAAI,CAACqB,aAAa,IAAIrB,IAAI,CAACf,IAAI,CAACkC,cAAc,CAAClC,IAAI,CAAC;MAC/D,OAAO,IAAI;IACf,CAAC,CAAC;IACF,IAAIiC,QAAQ,EAAE;MACV,OAAO,IAAI;IACf;EACJ;EACA,OAAO,KAAK;AAChB,CAAC;AAED,MAAMI,aAAa,GAAGA,CAACC,MAAM,EAAEC,QAAQ,EAAEtB,KAAK,KAAK;EAC/C,OAAO,IAAIpB,SAAS,CAACyC,MAAM,EAAE,CAACvC,KAAK,EAAEyC,KAAK,EAAEC,KAAK,EAAEpB,GAAG,KAAK;IACvD,MAAM;MAAEqB;IAAG,CAAC,GAAG3C,KAAK;IACpB,MAAME,IAAI,GAAGwC,KAAK;IAClB,IAAItC,EAAE,GAAGkB,GAAG;IACZ,MAAM,CAACsB,SAAS,GAAIC,OAAO,CAAC,GAAGJ,KAAK;IACpC,MAAMK,eAAe,GAAGF,SAAS,CAACG,MAAM,CAAC,IAAI,CAAC;IAC9C,IAAIF,OAAO,EAAE;MACT,MAAMG,SAAS,GAAGN,KAAK,GAAGE,SAAS,CAACK,OAAO,CAACJ,OAAO,CAAC;MACpD,MAAMK,OAAO,GAAGF,SAAS,GAAGH,OAAO,CAACxB,MAAM;MAC1C,IAAI6B,OAAO,GAAG5B,GAAG,EAAE;QACfqB,EAAE,CAACQ,MAAM,CAACD,OAAO,EAAE5B,GAAG,CAAC;MAC3B;MACA,IAAI0B,SAAS,GAAGN,KAAK,EAAE;QACnBC,EAAE,CAACQ,MAAM,CAACT,KAAK,GAAGI,eAAe,EAAEE,SAAS,CAAC;MACjD;MACA5C,EAAE,GAAGsC,KAAK,GAAGG,OAAO,CAACxB,MAAM,GAAGyB,eAAe;IACjD;IACAH,EAAE,CAACS,OAAO,CAAClD,IAAI,EAAEE,EAAE,EAAEoC,QAAQ,CAACa,MAAM,CAACnC,KAAK,CAAC,CAAC;IAC5CyB,EAAE,CAACW,gBAAgB,CAACd,QAAQ,CAAC;IAC7B,OAAOG,EAAE;EACb,CAAC,CAAC;AACN,CAAC;AAED,MAAMY,SAAS,GAAGA,CAACvD,KAAK,EAAEwD,QAAQ,KAAK;EACnC,MAAM;IAAErD;EAAM,CAAC,GAAGH,KAAK,CAACM,SAAS;EACjC,KAAK,IAAImD,CAAC,GAAGtD,KAAK,CAACY,KAAK,EAAE0C,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;IACtC,MAAMC,KAAK,GAAGvD,KAAK,CAACuD,KAAK,CAACD,CAAC,CAAC;IAC5B,IAAItD,KAAK,CAACa,IAAI,CAACyC,CAAC,CAAC,CAACE,cAAc,CAACD,KAAK,EAAEA,KAAK,EAAEF,QAAQ,CAAC,EAAE;MACtD,OAAO,IAAI;IACf;EACJ;EACA,OAAO,KAAK;AAChB,CAAC;;AAED;AACA;AACA;;AAEA,SAASD,SAAS,EAAE9B,iBAAiB,EAAEE,iBAAiB,EAAE5B,YAAY,EAAEkB,YAAY,EAAEa,WAAW,EAAEQ,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}