{"ast":null,"code":"import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform';\n\n/**\nInput rules are regular expressions describing a piece of text\nthat, when typed, causes something to happen. This might be\nchanging two dashes into an emdash, wrapping a paragraph starting\nwith `\"> \"` into a blockquote, or something entirely different.\n*/\nclass InputRule {\n  /**\n  Create an input rule. The rule applies when the user typed\n  something and the text directly in front of the cursor matches\n  `match`, which should end with `$`.\n  \n  The `handler` can be a string, in which case the matched text, or\n  the first matched group in the regexp, is replaced by that\n  string.\n  \n  Or a it can be a function, which will be called with the match\n  array produced by\n  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n  as well as the start and end of the matched range, and which can\n  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\n  rule's effect, or null to indicate the input was not handled.\n  */\n  constructor(\n  /**\n  @internal\n  */\n  match, handler, options = {}) {\n    this.match = match;\n    this.match = match;\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n    this.undoable = options.undoable !== false;\n    this.inCode = options.inCode || false;\n    this.inCodeMark = options.inCodeMark !== false;\n  }\n}\nfunction stringHandler(string) {\n  return function (state, match, start, end) {\n    let insert = string;\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1]);\n      insert += match[0].slice(offset + match[1].length);\n      start += offset;\n      let cutOff = start - end;\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert;\n        start = end;\n      }\n    }\n    return state.tr.insertText(insert, start, end);\n  };\n}\nconst MAX_MATCH = 500;\n/**\nCreate an input rules plugin. When enabled, it will cause text\ninput that matches any of the given rules to trigger the rule's\naction.\n*/\nfunction inputRules({\n  rules\n}) {\n  let plugin = new Plugin({\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, prev) {\n        let stored = tr.getMeta(this);\n        if (stored) return stored;\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin);\n      },\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            let {\n              $cursor\n            } = view.state.selection;\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n          });\n        }\n      }\n    },\n    isInputRules: true\n  });\n  return plugin;\n}\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false;\n  let state = view.state,\n    $from = state.doc.resolve(from);\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\n  for (let i = 0; i < rules.length; i++) {\n    let rule = rules[i];\n    if (!rule.inCodeMark && $from.marks().some(m => m.type.spec.code)) continue;\n    if ($from.parent.type.spec.code) {\n      if (!rule.inCode) continue;\n    } else if (rule.inCode === \"only\") {\n      continue;\n    }\n    let match = rule.match.exec(textBefore);\n    if (!match || match[0].length < text.length) continue;\n    let startPos = from - (match[0].length - text.length);\n    if (!rule.inCodeMark) {\n      let hasMark = false;\n      state.doc.nodesBetween(startPos, $from.pos, node => {\n        if (node.isInline && node.marks.some(m => m.type.spec.code)) hasMark = true;\n      });\n      if (hasMark) continue;\n    }\n    let tr = rule.handler(state, match, startPos, to);\n    if (!tr) continue;\n    if (rule.undoable) tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text\n    });\n    view.dispatch(tr);\n    return true;\n  }\n  return false;\n}\n/**\nThis is a command that will undo an input rule, if applying such a\nrule was the last thing that the user did.\n*/\nconst undoInputRule = (state, dispatch) => {\n  let plugins = state.plugins;\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i],\n      undoable;\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr,\n          toUndo = undoable.transform;\n        for (let j = toUndo.steps.length - 1; j >= 0; j--) tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        if (undoable.text) {\n          let marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n        dispatch(tr);\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\nConverts double dashes to an emdash.\n*/\nconst emDash = new InputRule(/--$/, \"—\", {\n  inCodeMark: false\n});\n/**\nConverts three dots to an ellipsis character.\n*/\nconst ellipsis = new InputRule(/\\.\\.\\.$/, \"…\", {\n  inCodeMark: false\n});\n/**\n“Smart” opening double quotes.\n*/\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\", {\n  inCodeMark: false\n});\n/**\n“Smart” closing double quotes.\n*/\nconst closeDoubleQuote = new InputRule(/\"$/, \"”\", {\n  inCodeMark: false\n});\n/**\n“Smart” opening single quotes.\n*/\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\", {\n  inCodeMark: false\n});\n/**\n“Smart” closing single quotes.\n*/\nconst closeSingleQuote = new InputRule(/'$/, \"’\", {\n  inCodeMark: false\n});\n/**\nSmart-quote related input rules.\n*/\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n\n/**\nBuild an input rule for automatically wrapping a textblock when a\ngiven string is typed. The `regexp` argument is\ndirectly passed through to the `InputRule` constructor. You'll\nprobably want the regexp to start with `^`, so that the pattern can\nonly occur at the start of a textblock.\n\n`nodeType` is the type of node to wrap in. If it needs attributes,\nyou can either pass them directly, or pass a function that will\ncompute them from the regular expression match.\n\nBy default, if there's a node with the same type above the newly\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\ntwo nodes. You can pass a join predicate, which takes a regular\nexpression match and the node before the wrapped node, and can\nreturn a boolean to indicate whether a join should happen.\n*/\nfunction wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    let tr = state.tr.delete(start, end);\n    let $start = tr.doc.resolve(start),\n      range = $start.blockRange(),\n      wrapping = range && findWrapping(range, nodeType, attrs);\n    if (!wrapping) return null;\n    tr.wrap(range, wrapping);\n    let before = tr.doc.resolve(start - 1).nodeBefore;\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) && (!joinPredicate || joinPredicate(match, before))) tr.join(start - 1);\n    return tr;\n  });\n}\n/**\nBuild an input rule that changes the type of a textblock when the\nmatched text is typed into it. You'll usually want to start your\nregexp with `^` to that it is only matched at the start of a\ntextblock. The optional `getAttrs` parameter can be used to compute\nthe new node's attributes, and works the same as in the\n`wrappingInputRule` function.\n*/\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs = null) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let $start = state.doc.resolve(start);\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null;\n    return state.tr.delete(start, end).setBlockType(start, start, nodeType, attrs);\n  });\n}\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };","map":{"version":3,"names":["Plugin","findWrapping","canJoin","InputRule","constructor","match","handler","options","stringHandler","undoable","inCode","inCodeMark","string","state","start","end","insert","offset","lastIndexOf","slice","length","cutOff","tr","insertText","MAX_MATCH","inputRules","rules","plugin","init","apply","prev","stored","getMeta","selectionSet","docChanged","props","handleTextInput","view","from","to","text","run","handleDOMEvents","compositionend","setTimeout","$cursor","selection","pos","isInputRules","composing","$from","doc","resolve","textBefore","parent","textBetween","Math","max","parentOffset","i","rule","marks","some","m","type","spec","code","exec","startPos","hasMark","nodesBetween","node","isInline","setMeta","transform","dispatch","undoInputRule","plugins","getState","toUndo","j","steps","step","invert","docs","replaceWith","schema","delete","emDash","ellipsis","openDoubleQuote","closeDoubleQuote","openSingleQuote","closeSingleQuote","smartQuotes","wrappingInputRule","regexp","nodeType","getAttrs","joinPredicate","attrs","Function","$start","range","blockRange","wrapping","wrap","before","nodeBefore","join","textblockTypeInputRule","canReplaceWith","index","indexAfter","setBlockType"],"sources":["/Users/diakaria/Documents/SAITECH/ANGULAR/visitrack/node_modules/prosemirror-inputrules/dist/index.js"],"sourcesContent":["import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform';\n\n/**\nInput rules are regular expressions describing a piece of text\nthat, when typed, causes something to happen. This might be\nchanging two dashes into an emdash, wrapping a paragraph starting\nwith `\"> \"` into a blockquote, or something entirely different.\n*/\nclass InputRule {\n    /**\n    Create an input rule. The rule applies when the user typed\n    something and the text directly in front of the cursor matches\n    `match`, which should end with `$`.\n    \n    The `handler` can be a string, in which case the matched text, or\n    the first matched group in the regexp, is replaced by that\n    string.\n    \n    Or a it can be a function, which will be called with the match\n    array produced by\n    [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n    as well as the start and end of the matched range, and which can\n    return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\n    rule's effect, or null to indicate the input was not handled.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    match, handler, options = {}) {\n        this.match = match;\n        this.match = match;\n        this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n        this.undoable = options.undoable !== false;\n        this.inCode = options.inCode || false;\n        this.inCodeMark = options.inCodeMark !== false;\n    }\n}\nfunction stringHandler(string) {\n    return function (state, match, start, end) {\n        let insert = string;\n        if (match[1]) {\n            let offset = match[0].lastIndexOf(match[1]);\n            insert += match[0].slice(offset + match[1].length);\n            start += offset;\n            let cutOff = start - end;\n            if (cutOff > 0) {\n                insert = match[0].slice(offset - cutOff, offset) + insert;\n                start = end;\n            }\n        }\n        return state.tr.insertText(insert, start, end);\n    };\n}\nconst MAX_MATCH = 500;\n/**\nCreate an input rules plugin. When enabled, it will cause text\ninput that matches any of the given rules to trigger the rule's\naction.\n*/\nfunction inputRules({ rules }) {\n    let plugin = new Plugin({\n        state: {\n            init() { return null; },\n            apply(tr, prev) {\n                let stored = tr.getMeta(this);\n                if (stored)\n                    return stored;\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            }\n        },\n        props: {\n            handleTextInput(view, from, to, text) {\n                return run(view, from, to, text, rules, plugin);\n            },\n            handleDOMEvents: {\n                compositionend: (view) => {\n                    setTimeout(() => {\n                        let { $cursor } = view.state.selection;\n                        if ($cursor)\n                            run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n                    });\n                }\n            }\n        },\n        isInputRules: true\n    });\n    return plugin;\n}\nfunction run(view, from, to, text, rules, plugin) {\n    if (view.composing)\n        return false;\n    let state = view.state, $from = state.doc.resolve(from);\n    let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\n    for (let i = 0; i < rules.length; i++) {\n        let rule = rules[i];\n        if (!rule.inCodeMark && $from.marks().some(m => m.type.spec.code))\n            continue;\n        if ($from.parent.type.spec.code) {\n            if (!rule.inCode)\n                continue;\n        }\n        else if (rule.inCode === \"only\") {\n            continue;\n        }\n        let match = rule.match.exec(textBefore);\n        if (!match || match[0].length < text.length)\n            continue;\n        let startPos = from - (match[0].length - text.length);\n        if (!rule.inCodeMark) {\n            let hasMark = false;\n            state.doc.nodesBetween(startPos, $from.pos, node => {\n                if (node.isInline && node.marks.some(m => m.type.spec.code))\n                    hasMark = true;\n            });\n            if (hasMark)\n                continue;\n        }\n        let tr = rule.handler(state, match, startPos, to);\n        if (!tr)\n            continue;\n        if (rule.undoable)\n            tr.setMeta(plugin, { transform: tr, from, to, text });\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\n/**\nThis is a command that will undo an input rule, if applying such a\nrule was the last thing that the user did.\n*/\nconst undoInputRule = (state, dispatch) => {\n    let plugins = state.plugins;\n    for (let i = 0; i < plugins.length; i++) {\n        let plugin = plugins[i], undoable;\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n            if (dispatch) {\n                let tr = state.tr, toUndo = undoable.transform;\n                for (let j = toUndo.steps.length - 1; j >= 0; j--)\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                if (undoable.text) {\n                    let marks = tr.doc.resolve(undoable.from).marks();\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                }\n                else {\n                    tr.delete(undoable.from, undoable.to);\n                }\n                dispatch(tr);\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\nConverts double dashes to an emdash.\n*/\nconst emDash = new InputRule(/--$/, \"—\", { inCodeMark: false });\n/**\nConverts three dots to an ellipsis character.\n*/\nconst ellipsis = new InputRule(/\\.\\.\\.$/, \"…\", { inCodeMark: false });\n/**\n“Smart” opening double quotes.\n*/\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\", { inCodeMark: false });\n/**\n“Smart” closing double quotes.\n*/\nconst closeDoubleQuote = new InputRule(/\"$/, \"”\", { inCodeMark: false });\n/**\n“Smart” opening single quotes.\n*/\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\", { inCodeMark: false });\n/**\n“Smart” closing single quotes.\n*/\nconst closeSingleQuote = new InputRule(/'$/, \"’\", { inCodeMark: false });\n/**\nSmart-quote related input rules.\n*/\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n\n/**\nBuild an input rule for automatically wrapping a textblock when a\ngiven string is typed. The `regexp` argument is\ndirectly passed through to the `InputRule` constructor. You'll\nprobably want the regexp to start with `^`, so that the pattern can\nonly occur at the start of a textblock.\n\n`nodeType` is the type of node to wrap in. If it needs attributes,\nyou can either pass them directly, or pass a function that will\ncompute them from the regular expression match.\n\nBy default, if there's a node with the same type above the newly\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\ntwo nodes. You can pass a join predicate, which takes a regular\nexpression match and the node before the wrapped node, and can\nreturn a boolean to indicate whether a join should happen.\n*/\nfunction wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        let tr = state.tr.delete(start, end);\n        let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs);\n        if (!wrapping)\n            return null;\n        tr.wrap(range, wrapping);\n        let before = tr.doc.resolve(start - 1).nodeBefore;\n        if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n            (!joinPredicate || joinPredicate(match, before)))\n            tr.join(start - 1);\n        return tr;\n    });\n}\n/**\nBuild an input rule that changes the type of a textblock when the\nmatched text is typed into it. You'll usually want to start your\nregexp with `^` to that it is only matched at the start of a\ntextblock. The optional `getAttrs` parameter can be used to compute\nthe new node's attributes, and works the same as in the\n`wrappingInputRule` function.\n*/\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs = null) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let $start = state.doc.resolve(start);\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType))\n            return null;\n        return state.tr\n            .delete(start, end)\n            .setBlockType(start, start, nodeType, attrs);\n    });\n}\n\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}