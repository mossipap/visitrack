import * as i0 from '@angular/core';
import { Pipe, Injectable, NgModule } from '@angular/core';

/**
 * Created by vadimdez on 28/06/16.
 */
class FilterPipe {
    static isFoundOnWalking(value, key) {
        let walker = value;
        let found = false;
        do {
            if (walker.hasOwnProperty(key) ||
                Object.getOwnPropertyDescriptor(walker, key)) {
                found = true;
                break;
            }
        } while ((walker = Object.getPrototypeOf(walker)));
        return found;
    }
    static isNumber(value) {
        return !isNaN(parseInt(value, 10)) && isFinite(value);
    }
    /**
     * Checks function's value if type is function otherwise same value
     */
    static getValue(value) {
        return typeof value === 'function' ? value() : value;
    }
    filterByString(filter) {
        if (filter) {
            filter = filter.toLowerCase();
        }
        return (value) => !filter ||
            (value ? ('' + value).toLowerCase().indexOf(filter) !== -1 : false);
    }
    filterByBoolean(filter) {
        return (value) => Boolean(value) === filter;
    }
    filterByObject(filter) {
        return (value) => {
            for (const key in filter) {
                if (key === '$or') {
                    if (!this.filterByOr(filter.$or)(FilterPipe.getValue(value))) {
                        return false;
                    }
                    continue;
                }
                if (!value || !FilterPipe.isFoundOnWalking(value, key)) {
                    return false;
                }
                if (!this.isMatching(filter[key], FilterPipe.getValue(value[key]))) {
                    return false;
                }
            }
            return true;
        };
    }
    isMatching(filter, val) {
        switch (typeof filter) {
            case 'boolean':
                return this.filterByBoolean(filter)(val);
            case 'string':
                return this.filterByString(filter)(val);
            case 'object':
                return this.filterByObject(filter)(val);
        }
        return this.filterDefault(filter)(val);
    }
    /**
     * Filter value by $or
     */
    filterByOr(filter) {
        return (value) => {
            const length = filter.length;
            const arrayComparison = (i) => value.indexOf(filter[i]) !== -1;
            const otherComparison = (i) => this.isMatching(filter[i], value);
            const comparison = Array.isArray(value)
                ? arrayComparison
                : otherComparison;
            for (let i = 0; i < length; i++) {
                if (comparison(i)) {
                    return true;
                }
            }
            return false;
        };
    }
    /**
     * Default filterDefault function
     */
    filterDefault(filter) {
        return (value) => filter === undefined || filter == value;
    }
    transform(array, filter) {
        if (!array) {
            return array;
        }
        switch (typeof filter) {
            case 'boolean':
                return array.filter(this.filterByBoolean(filter));
            case 'string':
                if (FilterPipe.isNumber(filter)) {
                    return array.filter(this.filterDefault(filter));
                }
                return array.filter(this.filterByString(filter));
            case 'object':
                return array.filter(this.filterByObject(filter));
            case 'function':
                return array.filter(filter);
        }
        return array.filter(this.filterDefault(filter));
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: FilterPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "17.3.8", ngImport: i0, type: FilterPipe, name: "filterBy", pure: false });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: FilterPipe });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: FilterPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'filterBy',
                    pure: false
                }]
        }, {
            type: Injectable
        }] });

/**
 * Created by vadimdez on 28/11/2016.
 */
class FilterPipeModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: FilterPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.8", ngImport: i0, type: FilterPipeModule, declarations: [FilterPipe], exports: [FilterPipe] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: FilterPipeModule, providers: [FilterPipe] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: FilterPipeModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [FilterPipe],
                    providers: [FilterPipe],
                    exports: [FilterPipe]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { FilterPipe, FilterPipeModule };
//# sourceMappingURL=ngx-filter-pipe.mjs.map
